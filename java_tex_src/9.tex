\documentclass[a4paper,11pt]{article}
\usepackage[latin2]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[magyar]{babel}
\usepackage{url}
\usepackage{indentfirst}
\frenchspacing
\author{legendi@inf.elte.hu}

\usepackage{graphicx}
\usepackage{amssymb}

\title{9. Gyakorlat}
\date{2010. április 13.}
\begin{document}
\maketitle

\section*{Reflection}
\textit{"Önelemzés"} - futás közben a program lekérdezheti a lehetõségeit, milyen részekbõl áll, etc. Lehetõségek: program passzív vizsgálata (pl. ahol a program publikus szolgáltatásainak felderítése, \emph{Java Beans}), ill. korlátozottan egyes részek módosítása (pl. láthatóság).

A \emph{Java Core Reflection} erõsen típusos, biztonságos felület osztályok, objektumok vizsgálatára, használható a következõkre (amennyiben a biztonsági szabályok engedélyezik):

\begin{itemize}
\item új objektumok, tömbök létrehozása
\item adattagok lekérdezése, módosítása
\item függvények lekérdezése, meghívása
\item tömbelemek lekérdezése, módosítása
\item új osztályok létrehozása
\end{itemize}

Fontos osztályok: \texttt{java.lang.reflect.*} csomag:

\begin{itemize}
\item \texttt{Field, Method, Constructor} adattagok, függvények (\texttt{invoke(...)}, konstruktorok (\texttt{newInstance(...)}) lekérdezéséhez
\item \texttt{Class} osztály-, ill. interfész információk eléréséhez
\item \texttt{Package} csomagok kezeléséhez
\item \texttt{Proxy} új osztályok létrehozásához
\item \texttt{Array} tömbök dinamikus létrehozása, lekérdezése
\item \texttt{Modifier} módosítók visszafejétsében segít (public, protected, etc.)
\end{itemize}

\subsection*{Class}
Objektumreferencia megszerzése:

\begin{enumerate}
\item Objektumtól lekérdezhetõ:\\
\texttt{Class<?> clazz = this.getClass();}

\item Osztálytól lekérdezhetõ:\\
\texttt{Class<?> intClazz = int.class;}

\item Közvetlenül név szerint lekérdezhetõ:\\
\texttt{Class<?> clazz = Class.forName("java.lang.Boolean");}

\item Új osztály létrehozása:\\
\texttt{Proxy.getProxyClass(clazz.getClassLoader(), clazz.getInterfaces())}
\end{enumerate}

\subsection*{Példa}
\begin{verbatim}
package gyak9;

import java.lang.reflect.Method;
import java.lang.reflect.Modifier;

public class ReflectionTest {
    public static void analyze(final Class<?> clazz) {
        System.out.println("Osztaly neve: " +
                 clazz.getName());
        System.out.println("Csomagja: " +
                clazz.getPackage());
        System.out.println("Osossztalyanak neve: " +
                clazz.getSuperclass());
        
        System.out.println("Deklaralt public fuggvenyek:");
        for ( final Method act : clazz.getDeclaredMethods() ) {
            if ( Modifier.isPublic( act.getModifiers() ) ) {
                System.out.println(act.getName());
            }
        }
    }
    
    public static void main(final String[] args) {
        analyze( ReflectionTest.class );
    }
}
\end{verbatim}

\subsubsection*{Feladatok}
Készíts egy programot, amely egyetlen parancssori argumentumot kap, egy osztály teljes hivatkozási nevét (\emph{fully qualified name}), és
\begin{enumerate} 
\item eldönti, hogy az adott osztály belsõ, névtelen, vagy lokális osztály-e. Ha egyik sem, akkor nézze meg, hogy felsorolási típus, annotáció vagy interfész-e (\emph{a sorrendre figyeljetek, mert az annotáció is interfésznek minõsül}).
\item bejárja az osztályban deklarált összes adattagot, és kiírja azok nevét, típusát, és módosítószavait.
\item megkeresi az osztály összes publikus, deklarlált konstruktorát, valamint kiírja azok paramétereinek a számát.
\item lekérdezi az összes adattagot, és megnézi, hogy hányhoz van getter, setter függvény definiálva, valamint hány olyan van, amelyhez mindkettõ definiálva van.
\item megvizsgálja, hogy az adott osztálynak van-e nullary (zero-arg) konstruktora, és ha talál ilyet, csinál belõle egy példányt, valamint az alapértelmezett \texttt{toString()} függvényének a segítségével kiírja a képernyõre.
\item kiírja az összes (azaz nem csak a deklarált!) függvény módosítószavait, visszatérési értékének típusát, nevét, valamint paramétereinek típusát.
\item végigmegy az adott osztály összes statikus függvényén, és készít egy listát az ezen függvények által dobható kivételekrõl.
\end{enumerate}

\bigskip
\noindent
\textbf{Részletek} \url{http://java.sun.com/javase/6/docs/api/java/lang/reflect/package-frame.html}

\bigskip
\noindent
\textbf{Megjegyzés} Primitív (+\texttt{void}) típusok, pl. boolean reprezentációjának \texttt{Class} példánya \texttt{java.lang.Boolean.TYPE}, rövidebb formája \texttt{boolean.class}, többinél ugyanígy.

\subsection*{Tömbök}
Az \texttt{Array} osztály segítségével manipulálhatók az elemek (getter, setter függvények), új tömbök hozhatók létre (\texttt{newInstance()}), ill. a \texttt{Class} osztálynak vannak hasznos függvényei, pl.:

\begin{verbatim}
package gyak9;

public class ReflectionArrayTest {
    public static void arrayTest(final Class<?> clazz) {
        if ( ! clazz.isArray()) {
            System.out.println("Nem tomb");
            return;
        }
        
        Class<?> act = clazz;
        int dim = 0;
        while (act.isArray()) {
            act = act.getComponentType();
            dim++;
        }
        
        System.out.println( dim + " dimenzios");
        System.out.println( "Belso tipusa: " +
                act.getSimpleName());
    }
    
    public static void main(final String[] args) {
        arrayTest( new int[][] { {1, 2}, {3}}.getClass() );
    }
}
\end{verbatim}

\bigskip
\noindent
\textbf{Megjegyzés} Hülye jelölés, nem szívrohamot kapni:
\begin{verbatim}
int[][] arr = { {1, 2}, {3} };
System.out.println( arr );

// Eredmeny: [[I@42e816
\end{verbatim}

Ok: B - byte, C - char, D - double, F - float, I- int, J - long, L\textit{osztálynév} - osztály vagy interfész, S - short, Z - boolean, [ - tömb

\subsection*{Feladat}
Készítsünk egy programot, amely képes létrehozni egy adott típusú tömböt, majd az elemeit beállítani egy kitüntetett értékre. A program a paramétereket parancssori argumentumként kapja (elég a 8 primitív típusra felkészülni, valamint \texttt{String} objektumokra).

\subsection*{Feladat}
Készíts egy mélységi \texttt{String deepToString(Object[] arr)} segédeljárást tömbökhöz! A függvénynek egyetlen paramétere legyen: a kiírni kívánt tömb. A függvény menjen végig a az elemeken, és vizsgálja meg õket. Ha az nem tömb, akkor fûzze hozzá a szöveges reprezentációját az objektumnak a visszaadott Stringhez. Ha tömb, akkor vizsgálja meg mind a nyolc primitív típusra (\texttt{elementClass == byte[].class}, etc.), és annak megfelelõen dolgozza fel az elemeket. Ha nem primitív típus az elemtípus, akkor hívja meg a rekurzív függvényt újabb feldolgozásra!

\subsection*{Függvények}
Függvényeket meg is tudunk hívni, ld. \texttt{Method\#invoke(Object o, Object... args)} függvény. Ha a függvény statikus, akkor az elsõ paraméter lehet \texttt{null} (különben reccs), paraméterlista lehet üres, visszatérési értéke egy \texttt{Object}. Példa:

\begin{verbatim}
package gyak9;

import java.lang.reflect.Method;

public class Invoking {
    public static int add(final int a, final int b) {
        return a + b;
    }
    
    public static void main(final String[] args) throws Exception {
        final Method method = Invoking.class.getMethod("add",
                new Class[] {
                    Integer.TYPE, Integer.TYPE
                });
        
        System.out.println( method.invoke(null, 1, 2) );
    }
}
\end{verbatim}

\subsection*{Feladat}
Készíts egy tetszõleges objektumot, majd reflection segítségével keresd meg az összes, paraméter nélküli getter függvényét! Ezeket hívd is meg reflection segítségével, és az eredményüket írd ki a képernyõre!

\newpage
\section*{+/- Feladat}
A feladatokat a \url{legendi@inf.elte.hu} címre küldjétek, \textbf{következõ szombat éjfélig}! A subject a következõképp nézzen ki:

\begin{verbatim}
csop<csoportszám>_gyak<gyakorlat száma>_<EHA-kód>_<feladatok száma>
\end{verbatim}

Például:

\begin{verbatim}
csop1_gyak9_LERIAAT_1
csop1_gyak9_LERIAAT_12
\end{verbatim}

Mellékelni csak a Java forrásfájlokat mellékeljétek (semmiképp ne teljes Eclipse/NetBeans projecteket), esetleg rarolva, zipelve, és egy levelet küldjetek (több levél esetén az utolsó mellékleteit értékelem)! További fontos kritériumok:
\begin{itemize}
\item A konvenciókra figyeljetek plz!
\item Ékezetes karaktereket \textbf{ne} használjatok! Fõleg azonosítók esetében ne! A Java ugyan ezt megengedi, ugyanakkor a különbözõ környezetekbe való konvertáláskor ($latin2 \leftrightarrow UTF-8 \leftrightarrow Cp1250$) összetörnek a karakterek! Az ilyen forrásokat fordítani, következésképp értékelni sem tudom.
\end{itemize}

\subsection*{1. Feladat}
Készítsünk egy programot, amely képes egy adott osztály osztály-hi\-e\-rar\-chi\-á\-ját elõállítani, valamint meg tudja mondani, hogy pontosan milyen interfészeket implementál (az õsosztályok által implementáltakat is)! Az osztály nevét parancssori argumentumként kapjuk. Példa:
\begin{verbatim}
interface I1 {}
interface I2 extends I1 {}

class A implements I2 {}
class B extends A {}
\end{verbatim}

A \texttt{B} osztály vizsgálata esetén a következõ listát adja vissza a program:

\begin{verbatim}
[class gyak9.B, class gyak9.A, interface gyak9.I2,
  interface gyak9.I1, class java.lang.Object]
\end{verbatim}

\subsection*{2. Feladat}
Bizonyítsd be, hogy a \texttt{String} osztály csak gyengén tekinthetõ \emph{immutable} osztálynak (azaz reflection segítségével kiügyeskedhetõ az általa reprezentált szöveg megváltoztatása)!

A szöveg legyen ugyanolyan hosszú, de egy karakterét tetszõlegesen változtasd meg. A program megírásához szükséged lesz a String osztály forráskódjára (esetleg reflectionnel történõ vizsgálatára), ezt a \emph{JDK/src.zip} fájlban találhatod meg (vagy a különbözõ IDE-k segíthetnek a felkutatásában, pl. Eclipse alatt a \emph{Ctrl + Snift + T} billentyûkombináció).

\bigskip
\noindent
\textbf{Megjegyzés} Az ilyesmivel azért csak offtosan! Mivel magában a reprezentációban turkálunk, anélkül, hogy figyelnénk az objektum konzisztenciájának megõrzésére, gondok lehetnek a használatából (pl. a \texttt{String\#hashCode()} is lazy instantiationnel cache-eli az eredményt)! Ugyanakkor - sajnos - néha elkerülhetetlen, ilyenkor rendkívül hasznos tud lenni ez a csel.

\end{document}

% Modifier.toString()
